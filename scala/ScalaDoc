Scala深入浅出

1. AOP 编程实践：主要适用范围有将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。
	
	通过抽象特质Ftrait 然后里面定义一系列抽象行为动作方法
	
	将不同业务上的行为处理定义成不同特定的Ctrait继承父特质： 实现动作需要执行的逻辑（一般做一些初始化操作后，调用具体动作方法，通过super.Method调用具体动作实现方法）
	
	业务类继承父特质并且实现该义务逻辑需要特定执行的动作方法，在对应的Ctrait中super调用中执行（如何构造这个业务类才能执行实现的动作方法呢？接着看）
	
	构建具体的业务类实例并且混入需要的Ctrait（new Class with Ctrait : 重要，只有混入需要的特质才能在super.Method中调用改业务中已经实现的动作方法）这样当具体业务逻辑调用动作时正式触发动作的产生
	
2. 对象运行中动态混入trait特征，只有在这个特质中具体实现了对象需要调用的某个方法	

3. 正则表达是式 和 模式匹配的结合

4. 本地函数： 函数内部定义函数体，使得定义的函数体不对外暴露。函数在scala中是一等公民，可当变量使用。

   函数式编程风格的一个重要设计原则：程序应该被解构成若干小的函数，每个完成一个定义良好的任务。单个函数经常很小。
   
   这种风格的好处是它给了程序员许多可以灵活组装成更复杂事物的建造模块。每个小块应该充分简化到足以单独理解。

5. 偏应用函数：参数个数不一定需要传递所有变量（scala编译器会自动产生一个apply方法），偏应用函数是一种表达式，你不需要提供函数需要的所有参数

6. 何谓闭包？闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数
	
	依照val addMore = (x: Int) => x + more这个函数文本在运行时创建的函数值（对象）被称为闭包：closure。名称源自于通过“捕获”自由变量的绑定对函数文本执行的“关闭”行动。
	
	不带自由变量的函数文本，如(x: Int) => x + 1，被称为封闭术语：closed term，这里术语：term指的是一小部分源代码。
	
	因此依照这个函数文本在运行时创建的函数值严格意义上来讲就不是闭包，因为(x: Int) => x + 1在编写的时候就已经封闭了。但任何带有自由变量的函数文本，如(x: Int) => x + more，都是开放术语：open term。
	
	因此，任何依照(x: Int) => x + more在运行期创建的函数值将必须捕获它的自由变量，more，的绑定。由于函数值是关闭这个开放术语(x: Int) => x + more的行动的最终产物，得到的函数值将包含一个指向捕获的more变量的参考，
	
	因此被称为闭包。闭包看到了闭包之外做出的对自由more的变化。反过来也同样。闭包对捕获变量作出的改变在闭包之外也可见

7.高阶函数：作为值得函数、匿名函数、带函数参数的函数、参数（类型）推断、闭包、SAM转换（在Java中，不支持函数作为参数传递，当要告诉另一个函数做某件事时，通常做法是蒋动作放在一个实现某接口的累中，然后将该类的一个实例传递给另一个方法  
            很都时候，这些接口都只有单个抽象方法。在Java中被称为SAM类型）、柯里化（def f（x:int）=（y:Int）=> x + y）、无参函数作为参数的简化写法（注：省去()，俗称 换名调用参数）
			
8. 模式匹配：模式匹配分析，守卫使用，变量使用。Type，Array，List，Tuple模式匹配的使用

9. case class 和 case object 、嵌套的case class（case class 当做参数传递在另一个case class 中）

10. Option：Some 和 None

11. List基于模式匹配的排序实现： 递归 + 选择排序的思想，每次选出最小的放在head的位置 (由局部排序到整体有序，归并排序的整体思想)

12. scala里允许带有小括号(无参)的方法在调用时省略小括号，但对于没有小括号(without parenthesis)的方法，调用时若增加了小括号却是意义不同的（实际会调用了apply方法）；apply方法是一种语法糖，可以用小括号来表示，不要与方法本身的小括号混淆
	
13. java中有4个命名空间：包 类型 方法 字段

	方法与字段是不同的命名空间，所以字段与方法同名是不会冲突的。

	而scala中仅有2个命名空间： 值（字段/方法/包/单例） 类型（类/特质）
	
	所以在scala可以实现用val重写无参方法这种事情。	

14. 自定义的值类型数组初始值都是null，与值类型的内部数据无关。因为自定义的值类型赋给数组时会装箱，它们都是被当作引用来对待的。但对值类型赋值时是不能用null来赋值的，不管是系统原生的值类型还是自定义的值类型

15. scala里获取类(Class)信息： 对于对象，typeOf 和 classOf 方法接收的都是类型符号(symbol)，并不是对象实例， 对于对象实例，要获取他的 Class 信息，只有通过 getClass 方法

16. 类和类型的阐述：

	类(class)与类型(type)是两个不一样的概念(在java里因为早期一直使用class表达type，并且现在也延续这样的习惯)；类型(type)比类(class)更”具体”，任何数据都有类型。类是面向对象系统里对同一类数据的抽象，在没有泛型之前，类型系统不存在高阶概念，直接与类一一映射，而泛型出现之后，就不在一一映射了。
	
	比如定义class List[T] {}, 可以有List[Int] 和 List[String]等具体类型，它们的类是同一个List，但类型则根据不同的构造参数类型而不同。

	类型一致的对象它们的类也是一致的，反过来，类一致的，其类型不一定一致。
	
17. 单例类型是个特殊的类型，单例类型绑定(依赖)在某个对象实例上，每个对象实例都有它的单例类型。所有的对象实例都有一个x.type的单例类型，它只对应当前对象实例（链式调用： 把返回类型都改为了 this.type 单例类型，就可以了，返回的就是当前对象类型，以便连贯的调用方法。它利用了this关键字的动态特性来实现的）

18. 概念：路径依赖类型 - 比如上面的 A.this.B 就是一个路径依赖类型，B 前面的路径 A.this 随着不同的实例而不同
	概念：类型投影 - 想要表达所有的外部类A实例路径下的B类型，即对 a1.B 和 a2.B及所有的 an.B类型找一个共同的父类型，这就是类型投影，用 A#B的形式表示（def foo(b: A#B)）

19. 中缀类型 - 需要注意的一点是名称最后以“:”结尾的，调用顺序与普通中缀操作符想反：从右往左。比如h :: t 实际是 t.::(h)，它的意义在于可以让表达看起来更“顺眼”一些，即 "one" Cons "two" 等同于 Cons("one", "two")

20. type关键字 - 声明一个类型别名，trait A { type T ; def foo(i:T) = print(i) } 这个结构类型内部也允许通过type来定义类型，这里对X没有赋值表示X是一个抽象类型，需要子类型在实现时提供X具体的类型

21. this的别名 - scala的源码的话很发现很多源码开头都有一句：self => 这句相当于给this起了一个别名为self， 但当声明了类型的时候，就不是别名的用途了，这个时候表示自身类型（class C { this:X => }，this:X => 要求C在实例化时或定义C的子类时，必须混入指定的X类型，这个X类型也可以指定为当前类型，val c = new C with X）

22. context bounds(上下文界定)也是隐式参数的语法糖

	scala> def max[T](a:T, b:T) (implicit cp : Comparator[T]) = { 
            if (cp.compareTo(b) > 0) a else b 
        }
		
	可以简化为：
	
	scala> def max2[T : Comparator] (a:T, b:T) = { 

				val cp = implicitly[Comparator[T]]

				if( cp.compare(a,b)>0) a else b 
			}
			
23. 如果一个类型支持协变或逆变，则称这个类型为variance(翻译为可变的或变型)，否则称为invariant(不可变的)，可以在定义类型时声明(用加号表示为协变，减号表示逆变)；

	要注意variance并不会被继承，父类声明为variance，子类如果想要保持，仍需要声明。
	
	FunctionN 在对其类型参数的定义，入参类型都是逆变（定义域范围父类更小）的，而结果类型是协变（值域范围父类更大）的。它反映了函数类型也是具有多态特性的（2个函数: f1, f2; 我们若能说f2是f1的子类，则f1（父类函数）能接受的任意参数，f2也能接受，且经由f2映射而得出的结果的类型，也一定在经由f1映射所得结果的类型的“范围内”(是其子类)）
	
24. 通用特质(universal traits)这个术语是不是因为值类型(value classes)在混入特质时需要特别的限制才发明的，还是以前就有这种定义只是在值类型中被用到而已。它指的是那些继承自Any的trait，并且内部成员只有def定义的方法，且没有初始化语句	