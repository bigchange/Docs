1. 什么是k-d树？

	一种分割k维数据空间的数据结构。主要应用于多维空间关键数据的搜索（如：范围搜索和最近邻搜索）。K-D树是二进制空间分割树的特殊的情况

2. 如何构建？
	
	k-d树是一个二叉树，每个节点表示一个空间范围。每个节点的数据类型包括（数据矢量，空间矢量，垂直分割平面的轴向序号split，左子树指针，右子树指针，父节点）
   
    1）确定split域：对于所有描述子数据（特征矢量），统计它们在每个维上的数据方差。以SURF特征为例，描述子为64维，可计算64个方差。挑选出最大值，对应的维就是split域的值。数据方差大表明沿该坐标轴方向上的数据分散得比较开，
		
		在这个方向上进行数据分割有较好的分辨率；
    
	2）确定Node-data域：数据点集Data-set按其第split域的值排序。位于正中间的那个数据点被选为Node-data。此时新的Data-set' = Data-set\Node-data（除去其中Node-data这一点）。
	
	3） 递归确定左右子树的结构

3. 应用场景： 查找算法，检索在k-d树中与查询点距离最近的数据点
   
    从root节点开始，DFS搜索（每个节点中都保存有split域，通过这个域可以知道在该节点上平面分割的方向，进而知道是进入左子树还是进入右子树）直到叶子节点，同时在stack中顺序存储已经访问的节点。
	
	如果搜索到叶子节点，当前的叶子节点被设为最近邻节点。
	
	然后通过stack回溯:
	
	如果当前点的距离比最近邻点距离近，更新最近邻节点.
	
	然后检查以最近距离为半径的圆是否和父节点的超平面相交.
	
	如果相交，则必须到父节点的另外一侧，用同样的DFS搜索法，开始检查最近邻节点。
	
	如果不相交，则继续往上回溯，而父节点的另一侧子节点都被淘汰，不再考虑的范围中.
	
	当搜索回到root节点时，搜索完成，得到最近邻节点。

4. 实例：假设有6个二维数据点{（2,3），（5,4），（9,6），（4,7），（8,1），（7,2）} 注：此例数据维度只有2维，所以可以简单地给x，y两个方向轴编号为0,1，也即split={0,1}

	2 3
	5 4
	9 6
	4 7
	8 1
	7 2
  
  计算 每个温维度的方差： 选取最大方差的维度。x 轴 > y 轴。所以split域值首先取0，也就是x轴方向，分割平面垂直x轴
  
  确定数据点域： 根据x轴向的数据排序（2,4,5,7,8,9）取中间值得到7，所以按节点（7,2）划分垂直x轴的平面，x值小于7位于（7,2）左子树，x值大于7位于右子树 左：（2,3），（5,4），（4,7）,；右：（8,1），（9,2）
  
  递归计算左右子树即可得到最后的k-d tree
  
  参考附图结果
	