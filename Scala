Scala深入浅出

1. AOP 编程实践：主要适用范围有将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。
	
	通过抽象特质Ftrait 然后里面定义一系列抽象行为动作方法
	
	将不同业务上的行为处理定义成不同特定的Ctrait继承父特质： 实现动作需要执行的逻辑（一般做一些初始化操作后，调用具体动作方法，通过super.Method调用具体动作实现方法）
	
	业务类继承父特质并且实现该义务逻辑需要特定执行的动作方法，在对应的Ctrait中super调用中执行（如何构造这个业务类才能执行实现的动作方法呢？接着看）
	
	构建具体的业务类实例并且混入需要的Ctrait（new Class with Ctrait : 重要，只有混入需要的特质才能在super.Method中调用改业务中已经实现的动作方法）这样当具体业务逻辑调用动作时正式触发动作的产生
	
2. 对象运行中动态混入trait特征，只有在这个特质中具体实现了对象需要调用的某个方法	

3. 正则表达是式 和 模式匹配的结合

4. 本地函数： 函数内部定义函数体，使得定义的函数体不对外暴露。函数在scala中是一等公民，可当变量使用。

   函数式编程风格的一个重要设计原则：程序应该被解构成若干小的函数，每个完成一个定义良好的任务。单个函数经常很小。
   
   这种风格的好处是它给了程序员许多可以灵活组装成更复杂事物的建造模块。每个小块应该充分简化到足以单独理解。

5. 偏应用函数：参数个数不一定需要传递所有变量（scala编译器会自动产生一个apply方法），偏应用函数是一种表达式，你不需要提供函数需要的所有参数

6. 何谓闭包？闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数
	
	依照val addMore = (x: Int) => x + more这个函数文本在运行时创建的函数值（对象）被称为闭包：closure。名称源自于通过“捕获”自由变量的绑定对函数文本执行的“关闭”行动。
	
	不带自由变量的函数文本，如(x: Int) => x + 1，被称为封闭术语：closed term，这里术语：term指的是一小部分源代码。
	
	因此依照这个函数文本在运行时创建的函数值严格意义上来讲就不是闭包，因为(x: Int) => x + 1在编写的时候就已经封闭了。但任何带有自由变量的函数文本，如(x: Int) => x + more，都是开放术语：open term。
	
	因此，任何依照(x: Int) => x + more在运行期创建的函数值将必须捕获它的自由变量，more，的绑定。由于函数值是关闭这个开放术语(x: Int) => x + more的行动的最终产物，得到的函数值将包含一个指向捕获的more变量的参考，
	
	因此被称为闭包。闭包看到了闭包之外做出的对自由more的变化。反过来也同样。闭包对捕获变量作出的改变在闭包之外也可见

7.高阶函数：作为值得函数、匿名函数、带函数参数的函数、参数（类型）推断、闭包、SAM转换（在Java中，不支持函数作为参数传递，当要告诉另一个函数做某件事时，通常做法是蒋动作放在一个实现某接口的累中，然后将该类的一个实例传递给另一个方法  
            很都时候，这些接口都只有单个抽象方法。在Java中被称为SAM类型）、柯里化（def f（x:int）=（y:Int）=> x + y）、无参函数作为参数的简化写法（注：省去()，俗称 换名调用参数）
			
8. 模式匹配：模式匹配分析，守卫使用，变量使用。Type，Array，List，Tuple模式匹配的使用

9. case class 和 case object 、嵌套的case class（case class 当做参数传递在另一个case class 中）

10. Option：Some 和 None

11. List基于模式匹配的排序实现： 递归 + 选择排序的思想，每次选出最小的放在head的位置 (由局部排序到整体有序，归并排序的整体思想)
	
	